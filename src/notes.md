# performance.timerify project

goal: implement timerify:
timerify(fn, {histogram: Histogram})

timerify modifies the passed-in histogram by registering events into it. The histogram can later print performance distribution after many runs.

Two main parts of this so far:

- implement timerify function in JS (because it wraps a user's function and that's annoying to pass across language boundaries)
- implement Histogram class in Zig (used by timerify but nice to have performance and it's in CPP in node)

## How I got timerify to work

Thanks Jarred for the help on this one.

performance.timerify is part of the `node:perf_hooks` global, so importing it takes this code path:

- `perf_hooks.ts`
  - this file was already here
  - note we get "Performance" from globalThis, so that's proof it's a global
  - `performance.timerify` calls via `JSPerformance.cpp`
- `JSPerformance.cpp`
  - this file was already here
  - name prefix "JS" implies codegen but this case is exception since it's part of webcore which we'd copied in and now manually edit
  - note the `JSPerformancePrototypeTableValues`:
    - for the other performance functions, they're implemented in C++ so we use `JSC::PropertyAttribute::Function` and `HashTableValue::NativeFunctionType` which call their respective C++ implementations
    - for timerify, we use `PropertyAttribute::Builtin` and `HashTableValue::BuiltinGeneratorType` which will call through an _autogenerated_ C++ file to arrive back at a JS/TS file. It uses the `performanceTimerifyCodeGenerator` identifier, which I'll explain below.
- `Performance.ts`
  - I created this file
  - the existance of this TS file in `src/js/builtins` means it'll receive codegen for any exported functions
  - we `export timerify`
  - codegen will generate this glue function: (camelCased) {filename}{functionName}CodeGenerator, which is why we used `performanceTimerifyCodeGenerator` in `JSPerformance.cpp`

Calling `timerify` from JS will just feel like you're calling `Performance.ts``timerify` directly. It "just works" as if the glue code weren't there.

## how I got Histogram to work

This one was a bit harder, because I implement the class in Zig.

I followed `node_fs.zig` for inspiration. Thanks Dave as well for walking me through initial setup.

importing Histogram from node:perf_hooks follows this code path:

- `perf_hooks.ts`
  - note the key bit here: `$zig("node_perf_hooks_histogram_binding.zig", "createPerfHooksHistogramBinding");`
    - `$zig()` calls into a zig binding
    - `node_perf_hooks_histogram_binding.zig` is in `src/bun.js/node`
    - `createPerfHooksHistogramBinding` is the function name
- `node_perf_hooks_histogram_binding.zig`
  - I made this file
  - let's look at `createPerfHooksHistogramBinding`:

```javascript
pub fn createPerfHooksHistogramBinding(global: *JSC.JSGlobalObject) callconv(.C) JSC.JSValue {
    const histogram = JSC.JSValue.createEmptyObject(global, 1);
    histogram.put(
        global,
        bun.String.init("createHistogram"),
        JSC.JSFunction.create(
            global,
            "createHistogram",
            &createHistogram,
            3, // function length
            .{},
        ),
    );

    return histogram;
}
```

- it must be pub fn
- it must receive `(global: *JSC.JSGlobalObject)`
- it must use `callconv(.C)` since it needs to speak C ABI for JS interop
- it must return a `JSC.JSValue`
- we want to create an object in JSC, which is the `JSC.JSValue` that's passed back to `perf_hooks.ts`
- we add the `createHistogram` as a function onto it. This is the name JS sees. The `3` is the max quantity of args.

- let's look at `createHistogram` itself, which is the function actually called by JS.

```javascript
  fn createHistogram(globalThis: *JSC.JSGlobalObject, _: *JSC.CallFrame) callconv(.C) JSC.JSValue {
    return bun.new(Histogram, .{}).toJS(globalThis);
}
```

- `bun.new(T, init_value)` creates the object on heap, and `.toJS(globalThis)` makes it a `JSC.JSValue` for return
  - you'll see later where the destroy happens.
- following this pattern, we can have an arbitrary Histogram struct, fully in Zig.

But there's more to do. We have the createHistogram function but we need to codegen a way to represent the Histogram class itself and pass it across Zig/JS boundaries.

- `src/bun.js/node/node.classes.ts`
  - this file defines classes that need to be codegen'ed
  - I add the histogram class, important fields have comments:

```javascript
define({
    name: "Histogram", // the name in JS
    construct: false,
    noConstructor: true,
    finalize: true, // this triggers the deallocation for bun.destroy
    configurable: false,
    hasPendingActivity: false,
    klass: {},
    JSType: "0b11101110",
    proto: {
      // we put methods here
      update: { // name in JS
        fn: "update", // name in Zig
        length: 1, // quantity of args
      },

      foo: { getter: "foo" }, // public getters, so that histogram.foo is gettable from JS
    },

    values: [],
  }),
```

- lastly, add the class to `generated_class_list.zig` as `JSC.Node.Histogram`

Ok, we're almost there. Now we need to look at the Histogram struct for a few subtle things we need to do.

```javascript
pub const Histogram = struct {
    pub usingnamespace JSC.Codegen.JSHistogram; // Important, makes the JS interop work

    // Zig native stuff
    foo: u64 = 0,
    const This = @This();

    // We can a custom, arbitrary method, make sure to add it to the class in node.classes.ts
    // It must have this function signature: (*Self, globalThis, callframe) callconv(.C) JSValue
    pub fn update(self: *This, globalThis: *JSC.JSGlobalObject, callframe: *JSC.CallFrame) callconv(.C) JSValue {
        // args come from the callframe
        const args = callframe.arguments(1).slice();
        if (args.len != 1) {
            globalThis.throwInvalidArguments("Expected 1 argument", .{});
            return .zero;
        }
        self.foo = args[0].to(u64);
        return .undefined; // JSValue equivalent of a void return
    }

    // Below is a bit of boilerplate we need

    // This boilerplate is for writting getters, at least for trivial types.
    const PropertyGetter = fn (this: *This, globalObject: *JSC.JSGlobalObject) callconv(.C) JSC.JSValue;
    fn getter(comptime field: meta.FieldEnum(This)) PropertyGetter {
        return struct {
            pub fn callback(this: *This, globalObject: *JSC.JSGlobalObject) callconv(.C) JSC.JSValue {
                const v = @field(this, @tagName(field));
                return globalObject.toJS(v, .temporary);
            }
        }.callback;
    }

    // We can add a getter to make self.foo public.
    // Make sure this is also added to node.classes.ts
    pub const foo = getter(.foo);

    // since we create Histogram objects with bun.new, we need to have it be destroyable
    // our node.classes.ts has finalize=true to generate the call to finalize
    // it expects this specific function name to destroy itself.
    pub fn finalize(self: *Histogram) callconv(.C) void {
        bun.destroy(self);
    }
};
```

## Upcoming:

- actually adding Histogram as an argument into timerify and making timerify call Histogram methods
- implementing all of Histogram
